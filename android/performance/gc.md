### Android 垃圾回收

#### Dalvik

**垃圾回收原因**

什么触发了垃圾回收以及是哪种回收。可能出现的原因包括：

- GC_CONCURRENT 在您的堆开始占用内存时可以释放内存的并发垃圾回收。

- GC_FOR_MALLOC 堆已满而系统不得不停止您的应用并回收内存时，您的应用尝试分配内存而引起的垃圾回收。

- GC_HPROF_DUMP_HEAP 当您请求创建 HPROF 文件来分析堆时出现的垃圾回收。

- GC_EXPLICIT 显式垃圾回收，例如当您调用 gc() 时（您应避免调用，而应信任垃圾回收会根据需要运行）。

- GC_EXTERNAL_ALLOC 这仅适用于 API 级别 10 及更低级别（更新版本会在 Dalvik 堆中分配任何内存）。
外部分配内存的垃圾回收（例如存储在原生内存或 NIO 字节缓冲区中的像素数据）。

**释放量**

从此次垃圾回收中回收的内存量。

**堆统计数据**

堆的可用空间百分比与（活动对象数量）/（堆总大小）。

**外部内存统计数据**

API 级别 10 及更低级别的外部分配内存（已分配内存量）/（发生回收的限值）。

**暂停时间**

堆越大，暂停时间越长。并发暂停时间显示了两个暂停：一个出现在回收开始时，另一个出现在回收快要完成时。
在这些日志消息积聚时，请注意堆统计数据的增大（上面示例中的 3571K/9991K 值）。如果此值继续增大，可能会出现内存泄漏。

### ART 

**垃圾回收原因**

什么触发了垃圾回收以及是哪种回收。可能出现的原因包括：

- Concurrent 不会暂停应用线程的并发垃圾回收。此垃圾回收在后台线程中运行，而且不会阻止分配。

- Alloc 您的应用在堆已满时尝试分配内存引起的垃圾回收。在这种情况下，分配线程中发生了垃圾回收。

- Explicit 由应用明确请求的垃圾回收，例如，通过调用 gc() 或 gc()。与 Dalvik 相同，在 ART 中，
最佳做法是您应信任垃圾回收并避免请求显式垃圾回收（如果可能）。不建议使用显式垃圾回收，因为它们会阻止分配线程并不必要地
浪费 CPU 周期。如果显式垃圾回收导致其他线程被抢占，那么它们也可能会导致卡顿（应用中出现间断、抖动或暂停）。

- NativeAlloc 原生分配（如位图或 RenderScript 分配对象）导致出现原生内存压力，进而引起的回收。

- CollectorTransition 由堆转换引起的回收；此回收由运行时切换垃圾回收引起。回收器转换包括将所有对象从空闲列表空间复制
到碰撞指针空间（反之亦然）。当前，回收器转换仅在以下情况下出现：在 RAM 较小的设备上，应用将进程状态从可察觉的暂停状态变
更为可察觉的非暂停状态（反之亦然）。

- HomogeneousSpaceCompact 齐性空间压缩是空闲列表空间到空闲列表空间压缩，通常在应用进入到可察觉的暂停进程状态时发生。
这样做的主要原因是减少 RAM 使用量并对堆进行碎片整理。

-DisableMovingGc 这不是真正的垃圾回收原因，但请注意，发生并发堆压缩时，由于使用了 GetPrimitiveArrayCritical，
回收遭到阻止。一般情况下，强烈建议不要使用 GetPrimitiveArrayCritical，因为它在移动回收器方面具有限制。

-HeapTrim 这不是垃圾回收原因，但请注意，堆修剪完成之前回收会一直受到阻止。

** 垃圾回收名称**

ART 具有可以运行的多种不同的垃圾回收。

- Concurrent mark sweep (CMS) 整个堆回收器，会释放和回收映像空间以外的所有其他空间。

- Concurrent partial mark sweep 几乎整个堆回收器，会回收除了映像空间和 zygote 空间以外的所有其他空间。

- Concurrent sticky mark sweep 生成回收器，只能释放自上次垃圾回收以来分配的对象。此垃圾回收比完整或部分标记清除运行
得更频繁，因为它更快速且暂停时间更短。

-Marksweep + semispace 非并发、复制垃圾回收，用于堆转换以及齐性空间压缩（对堆进行碎片整理）。

**释放的对象**

此次垃圾回收从非大型对象空间回收的对象数量。

**释放的大小**

此次垃圾回收从非大型对象空间回收的字节数量。

**释放的大型对象**

此次垃圾回收从大型对象空间回收的对象数量。

**释放的大型对象大小**

此次垃圾回收从大型对象空间回收的字节数量。

**堆统计数据**

空闲百分比与（活动对象数量）/（堆总大小）。

**暂停时间**

通常情况下，暂停时间与垃圾回收运行时修改的对象引用数量成正比。当前，ART CMS 垃圾回收仅在垃圾回收即将完成时暂停一次。
移动的垃圾回收暂停时间较长，会在大部分垃圾回收期间持续出现。如果您在 logcat 中看到大量的垃圾回收，
请注意堆统计数据的增大（上面示例中的 25MB/38MB 值）。如果此值继续增大，且始终没有变小的趋势，则可能会出现内存泄漏。
或者，如果您看到原因为“Alloc”的垃圾回收，那么您的操作已经快要达到堆容量，并且将很快出现 OOM 异常。

https://developer.android.com/studio/profile/investigate-ram?hl=zh-cn