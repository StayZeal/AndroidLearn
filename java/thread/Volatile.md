### Volatile使用

锁提供了两种主要特性：互斥（mutual exclusion） 和可见性（visibility）。互斥即一次只允许一个线程持有某个特定的锁，
因此可使用该特性实现对共享数据的协调访问协议，这样，一次就只有一个线程能够使用该共享数据。可见性要更加复杂一些，
它必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的 —— 如果没有同步机制提供的这种可见性保证，
线程看到的共享变量可能是修改前的值或不一致的值，这将引发许多严重问题。

#### 原理

1、强制内存刷新：对于volatile变量则要求工作内存中发生变化之后，必须马上回写到工作内存，而线程读取volatile变量的时候，
必须马上到工作内存中去取最新值而不是读取本地工作内存的副本，此规则保证了前面所说的“当线程A对变量X进行了修改后，
在线程A后面执行的其他线程能看到变量X的变动”

2、禁止指令重排序

#### 造成的现象

Volatile 变量具有 synchronized 的可见性特性，但是不具备原子特性。

#### 使用场景

Volatile 变量具有 synchronized 的可见性特性，但是不具备原子特性。这就是说线程能够自动发现 volatile 变量的最新值。
Volatile 变量可用于提供线程安全，但是只能应用于非常有限的一组用例：**多个变量之间或者某个变量的当前值与修改后值之间没有约束**。
因此，单独使用 volatile 还不足以实现计数器、互斥锁或任何具有与多个变量相关的不变式（Invariants）的类。

您只能在有限的一些情形下使用 volatile 变量替代锁。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：

1、对变量的写操作不依赖于当前值。
2、该变量没有包含在具有其他变量的不变式中。


#### 双重检验锁单例为什么要加Volatile关键字

首先，我们需要知道Volatile可以保证可见性和原子性，同时保证JVM对指令不会进行重排序。

其次，这点也很关键，对象的创建不是一步完成的，是一个符合操作，需要3个指令。

我们结合这一句代码来解释：

singleton = new Singleton();  
1
  指令1：获取singleton对象的内存地址
  指令2：初始化singleton对象
  指令3：将这块内存地址，指向引用变量singleton。

那么，这样我们就比较好理解，为什么要加入Volatile变量了。由于Volatile禁止JVM对指令进行重排序。
所以创建对象的过程仍然会按照指令1-2-3的有序执行。
反之，如果没有Volatile关键字，假设线程A正常创建一个实例，那么指定执行的顺序可能2-1-3，当执行到指令1的时候，
线程B执行getInstance方法，获取到的，可能是对象的一部分，或者是不正确的对象，程序可能就会报异常信息。
