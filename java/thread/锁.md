#### 耗时操作

等待锁：线程阻塞到唤起，需要用户态到内核态的切换。最耗时

加锁：也耗时，可以进行优化

#### 锁优化

自旋锁：不阻塞，一直等，可设置等待次数

自适应：虚拟机自己选择等待次数

锁消除：在一些不需要加锁的场景，不加锁。

锁粗化：避免频繁加锁

轻量级锁：依据：绝大部分的锁，在整个同步周期内都是不存在竞争的。无人竞争，使用CAS代替加锁。有人竞争，则加锁（重量级锁）

偏向锁：一旦获取，就一直持有，等有人竞争再释放。

> 轻量级锁和偏向锁都是基于对象头的字段
>

synchronized 和ReentrantLock区别：

- ReentrantLock可以实现公平锁、等待可中断、绑定多个条件

Java锁的具体实现：

ReentrantReadWriteLock：如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，即读的过程中不允许写，
这是一种悲观的读锁。

StampedLock：要进一步提升并发执行效率，Java 8引入了新的读写锁。StampedLock和ReadWriteLock相比，改进之处在于：
读的过程中也允许获取写锁后写入！这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有
写入，这种读锁是一种乐观锁。